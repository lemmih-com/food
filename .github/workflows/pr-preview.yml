name: PR Preview

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  deploy-preview:
    runs-on: ubuntu-24.04
    permissions:
      contents: read
      pull-requests: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Determinate Nix
      uses: DeterminateSystems/nix-installer-action@main

    - name: Configure Nix S3 cache
      uses: lemmih/nix-s3-cache-action@v1
      with:
        s3-endpoint: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}.r2.cloudflarestorage.com
        bucket: nix-cache
        aws-access-key-id: ${{ secrets.R2_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.R2_SECRET_ACCESS_KEY }}
        public-key: "food-ci-cache:2eICaC37vEBexPk98J0dRt5FzSX7f6hx0vRl9tPaUuM="
        private-key: ${{ secrets.NIX_CACHE_PRIVATE_KEY }}

    - name: Free up disk space
      run: |
        # Remove unnecessary software to free up space
        sudo rm -rf /usr/local/lib/android
        sudo rm -rf /usr/share/dotnet
        sudo rm -rf /opt/ghc
        df -h

    - name: Build website
      run: nix build .#website --no-link -o result
      timeout-minutes: 30

    - name: Get content hash
      id: content-hash
      run: |
        HASH=$(cat result/assets/content-hash.txt)
        echo "hash=$HASH" >> $GITHUB_OUTPUT
        echo "Content hash: $HASH"

    - name: Check for existing deployment
      id: check-deployment
      env:
        CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      run: |
        # Generate deployment name from PR number
        DEPLOYMENT_NAME="food-pr-${{ github.event.pull_request.number }}"
        echo "deployment_name=$DEPLOYMENT_NAME" >> $GITHUB_OUTPUT

        # Get hash from the global deployment (food.lemmih.com)
        EXISTING_HASH=""
        GLOBAL_URL="https://food.lemmih.com"

        # Check if global deployment exists by trying to fetch the hash file
        HASH_FILE=$(mktemp)
        HTTP_CODE=$(curl -s -o "$HASH_FILE" -w "%{http_code}" "$GLOBAL_URL/content-hash.txt" || echo "000")

        if [ "$HTTP_CODE" = "200" ]; then
          EXISTING_HASH=$(cat "$HASH_FILE")
          echo "existing_hash=$EXISTING_HASH" >> $GITHUB_OUTPUT
          echo "Global deployment hash: $EXISTING_HASH"
        else
          echo "existing_hash=" >> $GITHUB_OUTPUT
          echo "Could not fetch global deployment hash"
        fi
        rm -f "$HASH_FILE"

        # Determine if we need to deploy
        if [ "$EXISTING_HASH" = "${{ steps.content-hash.outputs.hash }}" ]; then
          echo "needs_deploy=false" >> $GITHUB_OUTPUT
          echo "Website content matches global deployment, skipping preview"
        else
          echo "needs_deploy=true" >> $GITHUB_OUTPUT
          echo "Website content differs from global deployment, preview needed"
        fi

    - name: Export production data
      if: steps.check-deployment.outputs.needs_deploy == 'true'
      env:
        CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      run: |
        echo "Exporting production data (data only, no schema)..."
        nix develop -c wrangler d1 export food-lemmih-com-ingredients --remote --no-schema --output=prod-data.sql

    - name: Create per-PR D1 database
      if: steps.check-deployment.outputs.needs_deploy == 'true'
      id: create-db
      env:
        CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      run: |
        PR_DB_NAME="food-pr-${{ github.event.pull_request.number }}-db"
        echo "db_name=$PR_DB_NAME" >> $GITHUB_OUTPUT

        # Check if database already exists - if so, delete it to start fresh
        EXISTING_DB=$(nix develop -c wrangler d1 list --json | jq -r ".[] | select(.name == \"$PR_DB_NAME\") | .uuid")

        if [ -n "$EXISTING_DB" ]; then
          echo "Database $PR_DB_NAME already exists, deleting to start fresh with production data"
          nix develop -c wrangler d1 delete "$PR_DB_NAME" --skip-confirmation || true
        fi

        echo "Creating new database: $PR_DB_NAME"
        # Create the database and capture the output
        CREATE_OUTPUT=$(nix develop -c wrangler d1 create "$PR_DB_NAME" 2>&1)
        echo "$CREATE_OUTPUT"

        # Extract the database ID from the output
        DB_ID=$(echo "$CREATE_OUTPUT" | grep -oP 'database_id\s*=\s*"\K[^"]+' || echo "$CREATE_OUTPUT" | grep -oP '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}')
        echo "db_id=$DB_ID" >> $GITHUB_OUTPUT
        echo "Created database with ID: $DB_ID"

        # Update wrangler.toml to use the per-PR database (needed for migrations and data import)
        sed -i "s/database_id = \"779425b4-cc96-4154-a422-bd45165d3bd1\"/database_id = \"$DB_ID\"/g" wrangler.toml
        sed -i "s/database_name = \"food-lemmih-com-ingredients\"/database_name = \"$PR_DB_NAME\"/g" wrangler.toml

    - name: Apply migrations to PR database
      if: steps.check-deployment.outputs.needs_deploy == 'true'
      env:
        CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      run: |
        nix develop -c wrangler d1 migrations apply ${{ steps.create-db.outputs.db_name }} --remote

    - name: Import production data to PR database
      if: steps.check-deployment.outputs.needs_deploy == 'true'
      env:
        CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      run: |
        echo "Importing production data into PR database..."
        nix develop -c wrangler d1 execute ${{ steps.create-db.outputs.db_name }} --remote --file=prod-data.sql
        echo "Production data imported to PR database"

    - name: Deploy to Cloudflare Workers
      if: steps.check-deployment.outputs.needs_deploy == 'true'
      env:
        CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        PR_NUMBER: ${{ github.event.pull_request.number }}
      run: |
        # Deploy using the Nix deployment app (wrangler.toml already updated with PR database)
        nix run .#deploy-preview

    - name: Set preview secrets
      if: steps.check-deployment.outputs.needs_deploy == 'true'
      env:
        CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
      run: |
        # Set ADMIN_PIN secret on the preview worker
        echo "${{ secrets.ADMIN_PIN }}" | nix develop -c wrangler secret put ADMIN_PIN --name "food-pr-${{ github.event.pull_request.number }}"

    - name: Comment on PR
      if: steps.check-deployment.outputs.needs_deploy == 'true'
      uses: actions/github-script@v7
      with:
        script: |
          const deploymentName = '${{ steps.check-deployment.outputs.deployment_name }}';
          const previewUrl = `https://${deploymentName}.lemmih.workers.dev`;
          const contentHash = '${{ steps.content-hash.outputs.hash }}';

          // Find existing comment
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });

          const botComment = comments.find(comment =>
            comment.user.type === 'Bot' &&
            comment.body.includes('Preview Deployment')
          );

          const prDbName = '${{ steps.create-db.outputs.db_name }}';
          const commentBody = `## ðŸš€ Preview Deployment

          Your preview deployment is ready!

          - **Preview URL**: ${previewUrl}
          - **Content Hash**: \`${contentHash}\`
          - **Deployment**: \`${deploymentName}\`
          - **Database**: \`${prDbName}\` (cloned from production, isolated)

          This preview will be updated automatically when you push new changes. The database is recreated from production data on each update.`;

          if (botComment) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body: commentBody,
            });
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: commentBody,
            });
          }
